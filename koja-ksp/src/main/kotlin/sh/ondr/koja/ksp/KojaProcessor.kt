@file:OptIn(KspExperimental::class)

package sh.ondr.koja.ksp

import com.google.devtools.ksp.KspExperimental
import com.google.devtools.ksp.getFunctionDeclarationsByName
import com.google.devtools.ksp.isAnnotationPresent
import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.KSPLogger
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.processing.SymbolProcessor
import com.google.devtools.ksp.symbol.ClassKind
import com.google.devtools.ksp.symbol.FileLocation
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.google.devtools.ksp.symbol.KSFile
import com.google.devtools.ksp.symbol.KSPropertyDeclaration
import com.google.devtools.ksp.symbol.KSType
import com.google.devtools.ksp.symbol.Origin
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import sh.ondr.koja.JsonSchema
import sh.ondr.koja.ksp.kdoc.parseKdoc

// TODO clean up
class KojaProcessor(
	val codeGenerator: CodeGenerator,
	val logger: KSPLogger,
	private val options: Map<String, String>,
) : SymbolProcessor {
	val originatingFiles = mutableListOf<KSFile>()
	val pkg = "sh.ondr.koja"
	val kojaMetaPackage = "$pkg.generated.meta"
	val kojaInitializerPackage = "$pkg.generated.initializer"
	val validated = mutableSetOf<KSType>()
	val visitingStack = mutableSetOf<KSType>()

	val generatedMetasFqs = mutableSetOf<String>()

	override fun process(resolver: Resolver): List<KSAnnotated> {
		// Validate and process
		resolver.getSymbolsWithAnnotation("sh.ondr.koja.JsonSchema")
			.filterIsInstance<KSClassDeclaration>()
			.forEach { classDecl ->
				classDecl.qualifiedName?.asString()?.let { fqName ->
					// If this class was generated by some other processor, find the original source that triggerd it
					val originalLocation = classDecl.containingFile
						?.declarations
						?.filterIsInstance<KSPropertyDeclaration>()
						?.find { propDecl ->
							propDecl.simpleName.asString() == "${classDecl.simpleName.asString()}OriginalSource"
						}?.docString
						?.trim()
						?.let { functionFq ->
							// For now, only support functions
							resolver.getFunctionDeclarationsByName(
								name = functionFq,
								includeTopLevel = true,
							).firstOrNull()?.location as? FileLocation
						}

					val error = checkTypeError(
						type = classDecl.asStarProjectedType(),
						originalLocation = originalLocation,
					)
					if (error == null) {
						classDecl.process(classDecl.qualifiedName!!.asString())
					} else {
						logger.error("Error processing ${classDecl.qualifiedName?.asString()}: $error", classDecl)
					}
				}
			}
		// Collect all generated metas
		generatedMetasFqs.addAll(resolver.getDeclarationsFromPackage(kojaMetaPackage).map { it.qualifiedName?.asString()!! })
		return listOf()
	}

	private fun KojaProcessor.checkTypeError(
		type: KSType,
		originalLocation: FileLocation? = null,
	): String? {
		// Skip already processed
		if (type in validated) {
			return null
		}

		// Check for cycles and skip
		if (type in visitingStack) {
			return null
		}

		val decl = type.declaration
		val qName = decl.qualifiedName?.asString()

		// Primitives
		val primitiveTypes = setOf(
			"kotlin.String", "kotlin.Char", "kotlin.Boolean",
			"kotlin.Byte", "kotlin.Short", "kotlin.Int", "kotlin.Long",
			"kotlin.Float", "kotlin.Double",
		)
		if (qName != null && primitiveTypes.contains(qName)) {
			validated.add(type)
			return null
		}

		// Sets
		if (qName == "kotlin.collections.Set") {
			if (type.arguments.size != 1) {
				return "Set must have exactly one type parameter."
			}
			val inner = type.arguments[0].type?.resolve() ?: return "Unable to resolve Set element type."
			val innerError = checkTypeError(inner)
			return if (innerError != null) {
				"Set element type not supported: $innerError"
			} else {
				validated.add(type)
				null
			}
		}

		// Lists
		if (qName == "kotlin.collections.List") {
			if (type.arguments.size != 1) {
				return "List must have exactly one type parameter."
			}
			val inner = type.arguments[0].type?.resolve() ?: return "Unable to resolve List element type."
			val innerError = checkTypeError(inner)
			return if (innerError != null) {
				"List element type not supported: $innerError"
			} else {
				validated.add(type)
				null
			}
		}

		// Maps
		if (qName == "kotlin.collections.Map") {
			if (type.arguments.size != 2) {
				return "Map must have exactly two type parameters (key and value)."
			}
			val keyType = type.arguments[0].type?.resolve() ?: return "Unable to resolve Map key type."
			val valueType = type.arguments[1].type?.resolve() ?: return "Unable to resolve Map value type."

			val keyQName = keyType.declaration.qualifiedName?.asString()
			if (keyQName != "kotlin.String") {
				return "Map key must be String, found: ${keyQName ?: "unknown"}."
			}
			val valueError = checkTypeError(valueType)
			return if (valueError != null) {
				"Map value type not supported: $valueError"
			} else {
				validated.add(type)
				null
			}
		}

		// Enums and classes
		val classDecl = decl as? KSClassDeclaration
		if (classDecl != null) {
			if (classDecl.isAnnotationPresent(SerialName::class)) {
				return "@JsonSchema classes must not be annotated with @SerialName."
			}
			if (classDecl.classKind == ClassKind.ENUM_CLASS) {
				// Enums
				if (decl.isAnnotationPresent(JsonSchema::class) == false) {
					return "Enums must be annotated with @JsonSchema."
				}
				validated.add(type)
				return null
			} else if (classDecl.classKind == ClassKind.CLASS) {
				// Classes
				if (decl.isAnnotationPresent(JsonSchema::class) == false) {
					return "Classes must be annotated with both @JsonSchema and @Serializable."
				}
				if (decl.isAnnotationPresent(Serializable::class) == false) {
					return "Classes must be annotated with both @JsonSchema and @Serializable."
				}
				// Add to visiting stack
				visitingStack.add(type)

				// Check class properties recursively
				decl.getAllProperties().forEach { prop ->
					if (prop.isAnnotationPresent(SerialName::class)) {
						return "Descendents of @JsonSchema must not be annotated with @SerialName."
					}
					val error = checkTypeError(prop.type.resolve())
					if (error != null) {
						return "Parameter '${prop.simpleName.asString()}' of class '${classDecl.qualifiedName?.asString()}' is not supported: $error"
					}
				}
				validated.add(type)
				visitingStack.remove(type)
				return null
			}
			return "Type '${classDecl.qualifiedName?.asString()}' is not a supported primitive, collection, enum, or @JsonSchema class."
		}

		return "Type '${qName ?: type.toString()}' is not supported."
	}

	fun KSClassDeclaration.process(root: String) {
		if (origin == Origin.KOTLIN_LIB || origin == Origin.JAVA_LIB) {
			// Skip already compiled files
			return
		}

		// If there is a KDoc, parse it and generate the KojaMeta
		docString?.let { docString ->
			val kdoc = parseKdoc(
				kdoc = docString,
				parameters = getParamInfos().map { it.name },
			)
			originatingFiles.add(containingFile!!)
			generateKojaMeta(
				fqName = qualifiedName!!.asString(),
				kdoc = kdoc,
			)
		}
	}

	fun KSClassDeclaration.getParamInfos(): List<ParamInfo> {
		return primaryConstructor
			?.parameters
			?.mapIndexed { index, p ->
				ParamInfo(
					name = p.name?.asString() ?: "arg$index",
					fqnType = p.type.resolve().toFqnString(),
					readableType = p.type.resolve().toString(),
					ksType = p.type.resolve(),
					isNullable = p.type.resolve().isMarkedNullable,
					hasDefault = p.hasDefault,
					isRequired = !(p.hasDefault || p.type.resolve().isMarkedNullable),
				)
			} ?: emptyList()
	}

	// Generate module-wide initializer
	override fun finish() {
		generateInitializer()
	}
}
